
# 每日问题

1. 引用

Q: (20200312) 引用是变量的别名，指针存放的是变量的地址,引用直接访问到变量，指针间接访问到变量，指针存储变量的地址很好理解，请问引用这种可以直接访问变量的底层逻辑是怎么实现的？

A： 所以说这些概念真的误导人，你这段话哪里看来的。。。引用本质上就是指针，它访问的时候跟指针一模一样就是用的地址，引用和指针都是通过地址直接访问到变量。
    用唯一的特殊性是它没有办法声明为空，字面上给人感觉总是指向一个存在的东西，但是实际上你也可以把一个空指针解引用赋给一个引用。另外const引用这个常用套路你也知道了，
    所以引用本质上是个语法糖，没有任何新鲜的，增加可读性，可维护性而已，没有它，日子一样过。当然，等到了右值引用就是另一个世界了，那个太复杂了。

2. 线程安全 

Q: (20200313) 类似 br_tensorflow 中 BrKernelUtil 类，仅仅是一些接口, 这些接口的数据是外部 class 传入的；针对这种接口类，怎么保证线程安全；我有几个思路： 
    1）这种接口类本身就不应该存在，外部 class 的数据，以及对于这些数据的修改，都应该成为该 class 自身的成员函数，并且做好线程安全的控制； 
    2）另一个思路是, 针对 BrKernelUtil 的接口做线程安全的操作，对传入的数据加锁； 
    3）还有一个思路就是， 针对存在多线程，调用 BrKernelUtil 类中的接口的时候，直接对接口加锁， 比如 直接对 ReorderD2D() ， 加锁； 
    
问题是： 上述思路，是不是第一个更正确点？ 后面两种有点挫。 另外我们在设计一个纯接口的类的时候，怎么注意做到线程安全？

A: 通常是套路1，然后这个类里面的这些函数本质上是全局函数，就是一系列线程安全函数的组合，但是那样的话还是会断片，因为一套组合拳打下来，中间可能被打断。
    所以你原先的思路，单例，然后进入这堆函数的时候加锁就显得合理了，一套组合拳只要加一次锁，但是带来的困惑是，所有拥有数据的类的成员函数在别处，被别的线程调用时，
    如果类本身没有锁，还是有线程问题，那么又回到了套路1，所以感觉最终还是套路1胜出。
    
    加锁永远是对逻辑加锁，而这些逻辑必然操作数据，因为只有数据才有竞争，数据又是归一些类拥有，所以套路1就显得合理了。


3. marco and #define

Q:(20200314) 《Effective C++》中建议，形似函数的宏，最好改用 inline 函数替换 #define. 我们都知道， inline 和 #define 都比普通函数更高效；
    我发现在我们的代码仓中很多都是 #define 形式的函数，而不是 inline ！

    问题是：inline 和 #define 这两种形式，我们在开发过程中，要确定在什么场景下使用更合理？

A: 只要能写成函数，必然inline，效率和宏一样，还多了各种check，真实debug的时候也是会有堆栈，可能是IDE帮忙产生的。没法写成函数，或者有些是代码片段，
    不得已才用宏。宏更灵活，不拘泥，所以使用场景也很多，也可以大幅减少代码重复。 

```shell
附说明：
1.宏（#define）和内联函数（inline）的理解以及区别：

宏
缺点：
    1.宏没有类型检测，不安全
    2.宏是在预处理时进行简单文本替换，并不是简单的参数传递（很难处理一些特定情况。例如：Add(z++)）
    3.使代码变长
    4.宏不能进行调试
    5.当预处理搜索#define定义的符号时，字符串常量并不被搜索

优点：
    1.加快了代码的运行效率
    2.让代码变得更加的通用

内联函数
类中的成员函数是默认的内联函数
内联函数内不准许有循环语句和开关语句
内联函数的定义必须出现在第一次调用内联函数之前


缺点：
    代码变长，占用更多内存

优点：
    1.有类型检测，更加的安全
    2.内联函数是在程序运行时展开，而且是进行的是参数传递
    3.编译器可以检测定义的内联函数是否满足要求，如果不满足就会当作普通函数调用（内联函数不能递归，内联函数不能太大）

对比
相同点：
两者都是可以加快程序运行效率，使代码变得更加通用

不同点：
    1.内联函数的调用是传参，宏定义只是简单的文本替换
    2.内联函数可以在程序运行时调用，宏定义是在程序编译进行
    3.内联函数有类型检测更加的安全，宏定义没有类型检测
    4.内联函数在运行时可调式，宏定义不可以
    5.内联函数可以访问类的成员变量，宏不可以
    6.类中的成员函数是默认的内联函数
```


4. Q:(20200315) 在上次我写了 singleton 之后（缺少一次 nullptr 判断）， 我今天再本地新写了一个简单的测试例子，就当前这种例子而言，这个 singleton 还有什么优化的空间吗？或者说目前还有没有缺点？
